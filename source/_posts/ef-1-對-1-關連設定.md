---
title: ef 1 對 1 關連設定
date: 2020-12-18 01:11:56
tags:
- sql
- ef
---
&nbsp;
<!-- more -->

sql
```
CREATE TABLE TestMaster(
	id bigint primary key identity not null,
	Name nvarchar(50) not null
)

CREATE TABLE TestDetail(
	id bigint not null ,

	IsActive bit ,
	
	CONSTRAINT [PK_Test] PRIMARY KEY CLUSTERED 
	(
		[id] ASC
	)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
```

ef
```
public abstract class TestMaster{
	public int Id {get;set;}
	public string {get;set;}
}

public class TestDetail : TestMaster{
	public bool IsActive {get;set;}
	
	[ForeignKey( "id" )]
	public virtual TestMaster TestMaster{get;set;}
}
```
另外 1 對 1 關聯實務上其實滿多雷的 , 萬一要多擴充資料表的話 , 最好每個擴充表的 column 都設定可以允許 null 保持彈性
為何呢? 假設拆開資料表之前是長這樣

```
CREATE TABLE TestFull(
	id bigint primary key identity not null,
	Name nvarchar(50) not null ,

	--規劃第二張表
	IsActive bit null,

	--規劃第三張表
	--TheArea nvarchar(250) null,
	--Lon decimal(11,8) null,
	--Lat decimal(10,8) null,
)
```

假設一開始單一資料表只有 `IsActive` 這個欄位時資料長這樣
後續在單一資料表上面擴充的話 , 新設定的欄位一定是允許 null 不然就要給預設值 , 也很直覺
```
1	Test1	0
2	Test2	1
3	Test3	1
4	Test4	0
```

拆開後為這樣 , 這裡顯而易見 , 如果直接設定擴充表的欄位為 not null 的話 , 舊資料馬上就吃土 , 要逐一補上去
```
CREATE TABLE TestDetail(
	id bigint not null ,

	IsActive bit ,
	CONSTRAINT [PK_Test] PRIMARY KEY CLUSTERED
	(
		[id] ASC
	)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]


CREATE TABLE TestDetail2(
	id bigint not null ,

	TheArea nvarchar(250) null,
	Lon decimal(11,8) null,
	Lat decimal(10,8) null,
	CONSTRAINT [PK_Test2] PRIMARY KEY CLUSTERED
	(
		[id] ASC
	)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
```

另外就是擴充資料表以後大概率需要進行 `補 id` 這個動作 , 否則擴充的資料丟給前端 , 一定噴 null 這類的錯誤 , 為何呢
假設沒拆之前資料進行擴充後 , 大概會長這樣 , 新增的欄位資料可以為 null , 但是不會沒有 id 吧!
```
1	Test1	0	null	null	null
2	Test2	1	null	null	null
3	Test3	1	null	null	null
4	Test4	0	null	null	null
```

所以擴充後可以用這樣來查那些擴充表尚未補到 id
```
select id as TestDetail2
from TestMaster
except
select id
from TestDetail2
```

補 id 的話則是這樣
```
insert into TestDetail2(id)
select id
from TestMaster
except
select id
from TestDetail2
```
